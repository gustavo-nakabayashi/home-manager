#!/usr/bin/env bash

# gwa - Git Worktree Add with smart folder naming
# Usage: gwa <branch-name>
# Example: gwa feature/CORE-3670-Allow-form.io-choices-widget-to-use-search-and-select-in-our-styling
#          Creates folder: feature-CORE-3670

if [[ $# -ne 1 ]]; then
    echo "Usage: gwa <branch-name>"
    echo "Example: gwa feature/CORE-3670-Allow-form.io-choices-widget-to-use-search-and-select-in-our-styling"
    exit 1
fi

branch_name="$1"

# Check if we're in a bare repo
git_dir=$(git rev-parse --git-dir 2>/dev/null)
if [[ ! $git_dir ]]; then
    echo "Error: Not in a git repository"
    exit 1
fi

# Check if we're in a bare repository
if git rev-parse --is-bare-repository &>/dev/null && [[ $(git rev-parse --is-bare-repository) == "true" ]]; then
    echo "Using bare repository"
    bare_repo_dir="$PWD"
    work_dir="$(dirname "$PWD")"
else
    echo "Using worktree repository"
    # We're in a worktree, find the associated bare repo
    git_common_dir=$(git rev-parse --git-common-dir)
    if [[ "$git_common_dir" != "$git_dir" ]]; then
        # This is a worktree, the common dir points to the main repo
        bare_repo_dir="$git_common_dir"
        work_dir="$(dirname "$git_common_dir")"
    else
        # This is the main repo, not a bare setup
        git_root=$(git rev-parse --show-toplevel)
        bare_repo_dir=""
        work_dir="$git_root"
    fi
fi

# Get repo name from current directory or bare repo
if [[ -n "$bare_repo_dir" ]]; then
    repo_name=$(basename "$bare_repo_dir" .git)
else
    repo_name=$(basename "$work_dir")
fi

# Extract folder name from branch
# feature/CORE-3670-Allow-form.io-choices-widget-to-use-search-and-select-in-our-styling
# becomes: bridge-app-ui-3670-in-our-styling
if [[ "$branch_name" =~ ^[^/]+/[^-]+-([0-9]+) ]]; then
    # Extract just the number (e.g., 3670)
    task_number="${BASH_REMATCH[1]}"
    
    # Extract the description part after the task number
    description="${branch_name#*/}"
    description="${description#*-*-}"  # Remove prefix and task number
    
    # Split description into words and get the last 3 (or fewer if less than 3)
    IFS='-' read -ra words <<< "$description"
    word_count=${#words[@]}
    
    if [[ $word_count -ge 3 ]]; then
        last_words="${words[-3]}-${words[-2]}-${words[-1]}"
    elif [[ $word_count -eq 2 ]]; then
        last_words="${words[-2]}-${words[-1]}"
    elif [[ $word_count -eq 1 ]]; then
        last_words="${words[-1]}"
    else
        last_words=""
    fi
    
    # Create folder name: repo-number-lastwords
    if [[ -n "$last_words" ]]; then
        folder_name="${repo_name}-${task_number}-${last_words,,}"
    else
        folder_name="${repo_name}-${task_number}"
    fi
else
    # Fallback: replace slashes with dashes and truncate
    branch_clean=$(echo "$branch_name" | sed 's|/|-|g' | cut -c1-30)
    folder_name="${repo_name}-${branch_clean,,}"  # lowercase
fi

target_path="$work_dir/$folder_name"

echo "Fetching latest changes..."
if [[ -n "$bare_repo_dir" ]]; then
    git -C "$bare_repo_dir" fetch origin
else
    git fetch origin
fi

echo "Creating worktree for branch: $branch_name"
echo "Target folder: $target_path"

# Check if branch exists remotely
if [[ -n "$bare_repo_dir" ]]; then
    branch_exists=$(git -C "$bare_repo_dir" show-ref --verify --quiet refs/remotes/origin/"$branch_name" && echo "yes" || echo "no")
else
    branch_exists=$(git show-ref --verify --quiet refs/remotes/origin/"$branch_name" && echo "yes" || echo "no")
fi

if [[ "$branch_exists" == "yes" ]]; then
    echo "‚ö†Ô∏è  Branch exists remotely, checking it out instead of creating new"
    if [[ -n "$bare_repo_dir" ]]; then
        git -C "$bare_repo_dir" worktree add "$target_path" "$branch_name"
    else
        git worktree add "$target_path" "$branch_name"
    fi
else
    echo "Creating new branch based on origin/main"
    if [[ -n "$bare_repo_dir" ]]; then
        git -C "$bare_repo_dir" worktree add -b "$branch_name" "$target_path" origin/main
        # Fix tracking: new branches should not track origin/main
        git -C "$bare_repo_dir" config --unset "branch.${branch_name}.remote" 2>/dev/null || true
        git -C "$bare_repo_dir" config --unset "branch.${branch_name}.merge" 2>/dev/null || true
    else
        git worktree add -b "$branch_name" "$target_path" origin/main
        # Fix tracking: new branches should not track origin/main
        git config --unset "branch.${branch_name}.remote" 2>/dev/null || true
        git config --unset "branch.${branch_name}.merge" 2>/dev/null || true
    fi
    echo "üí° Remember to push with: git push -u origin $branch_name"
fi

if [[ $? -eq 0 ]]; then
    echo "‚úÖ Worktree created successfully!"
    echo "üìÅ Path: $target_path"
    echo "üåø Branch: $branch_name"

    # Copy necessary files from main worktree
    basePath="$work_dir/main"
    if [[ -d "$basePath" ]]; then
        paths=(.env .mcp.json .envrc)
        for path in "${paths[@]}"; do
            if [[ -f "$basePath/$path" ]]; then
                ln -sf "$basePath/$path" "$target_path/$path"
                echo "‚úÖ Linked $path"
            fi
        done
    fi

    echo ""
    echo "To switch to this worktree:"
    echo "  cd $target_path"
else
    echo "‚ùå Failed to create worktree"
    exit 1
fi
